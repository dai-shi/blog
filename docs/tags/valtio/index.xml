<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Valtio on Daishi Kato&#39;s blog</title>
    <link>https://blog.axlight.com/tags/valtio/</link>
    <description>Recent content in Valtio on Daishi Kato&#39;s blog</description>
    <generator>Hugo</generator>
    <language>en-us</language>
    <lastBuildDate>Sun, 18 Aug 2024 21:00:00 +0900</lastBuildDate>
    <atom:link href="https://blog.axlight.com/tags/valtio/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>How Valtio Was Born</title>
      <link>https://blog.axlight.com/posts/how-valtio-was-born/</link>
      <pubDate>Sun, 18 Aug 2024 21:00:00 +0900</pubDate>
      <guid>https://blog.axlight.com/posts/how-valtio-was-born/</guid>
      <description>Introduction There was a discussion in our team after releasing Zustand v3 and the brand new Jotai. It was about whether we could develop another library for global state.&#xA;In this post, I will reflect on the start of Valtio&amp;rsquo;s development and its API design.&#xA;Hesitation at First While the idea of a proxy state sounded promising, I was hesitant to develop a third global state library at first. We were already maintaining two libraries in the same problem domain.</description>
    </item>
    <item>
      <title>When I Use Valtio and When I Use Jotai</title>
      <link>https://blog.axlight.com/posts/when-i-use-valtio-and-when-i-use-jotai/</link>
      <pubDate>Sun, 30 Jan 2022 18:00:00 +0900</pubDate>
      <guid>https://blog.axlight.com/posts/when-i-use-valtio-and-when-i-use-jotai/</guid>
      <description>Introduction Recently, I often got asked about this question: Which is recommended, valtio or jotai?&#xA;For those who are not familiar with them, they are two out of many state management libraries that I developed.&#xA;https://github.com/pmndrs/valtio&#xA;https://github.com/pmndrs/jotai&#xA;Now, from the library perspective, their implementations are very different. However, from the usage perspective, I understand the confusion. Both serve similar functionalities and we don&amp;rsquo;t usually use both in a single app.</description>
    </item>
    <item>
      <title>How Valtio Proxy State Works (React Part)</title>
      <link>https://blog.axlight.com/posts/how-valtio-proxy-state-works-react-part/</link>
      <pubDate>Sun, 26 Dec 2021 22:00:00 +0900</pubDate>
      <guid>https://blog.axlight.com/posts/how-valtio-proxy-state-works-react-part/</guid>
      <description>Introduction In the previous article, we explained how Valtio proxy state works. It tracks mutations of state and create immutable snapshot.&#xA;Let&amp;rsquo;s recap the API in vanilla part of Valtio.&#xA;// Create a new proxy state to detect mutations const state = proxy({ count: 0 }); // You can mutate it ++state.count; // Create a snapshot const snap1 = snapshot(state); // ---&amp;gt; { count: 1 } // Mutate it again state.</description>
    </item>
    <item>
      <title>How Valtio Proxy State Works (Vanilla Part)</title>
      <link>https://blog.axlight.com/posts/how-valtio-proxy-state-works-vanilla-part/</link>
      <pubDate>Fri, 27 Aug 2021 22:00:00 +0900</pubDate>
      <guid>https://blog.axlight.com/posts/how-valtio-proxy-state-works-vanilla-part/</guid>
      <description>Introduction Valtio is a library for global state primarily for React. It&amp;rsquo;s originally modeled to match with useMutableSource API. However, it turns out it&amp;rsquo;s a novel API to add immutability to mutable state.&#xA;What is immutable state? JavaScript doesn&amp;rsquo;t support immutability as language, so it&amp;rsquo;s just a coding contract.&#xA;const immutableState1 = { count: 0, text: &amp;#39;hello&amp;#39; }; // update the state const immutableState2 = { ...immutableState1, count: immutableState1.count + 1 }; // update it again const immutableState3 = { .</description>
    </item>
  </channel>
</rss>
